# 关联规则之Aprior算法:python实现

> Aprior算法为经典的关联规则算法，主要思想是通过计算历史数据统计不同规则出现的频率与先后关系，来进行关联规则的识别。

其主要思想为：

1. 找出顾客购买记录数据集中的频繁项集，频繁项集满足大于等于最小支持度；
2. 根据频繁项集产生强关联规则，关联规则必须满足最小支持度和最小置信度的要求；

以上两条条件缺一不可。

其中所提到的支持度与置信度的计算方式如下：

若存在规则X -> Y，则代表顾客购买X商品以后会购买Y商品，此时的支持度与置信度：

![[公式]](https://www.zhihu.com/equation?tex=Support%28X+%5Crightarrow+Y%29%3D%5Cfrac%7B%E5%90%8C%E6%97%B6%E5%8C%85%E5%90%ABXY%E6%95%B0%E6%8D%AE%E6%95%B0%7D%7B%E6%95%B0%E6%8D%AE%E6%80%BB%E6%95%B0%7D)

![[公式]](https://www.zhihu.com/equation?tex=Confidence%28X%5Crightarrow+Y%29%3D%5Cfrac%7B%E5%90%8C%E6%97%B6%E5%8C%85%E5%90%ABXY%E7%9A%84%E6%95%B0%E6%8D%AE%E6%95%B0%7D%7B%E5%8C%85%E5%90%ABX%E7%9A%84%E6%95%B0%E6%8D%AE%E6%95%B0%7D)

通过定义支持度与置信度，可以人为规定**最小支持度**与 **最小置信度** ，以得到最终的关联规则项集。

此外，还有 **“提升度”、“杠杆率”与“确信度”** 三种衡量关联规则关系的标准。

![[公式]](https://www.zhihu.com/equation?tex=lift%28X%5Crightarrow+Y%29%3D%5Cfrac%7Bsupport%28X%5Ccap+Y%29%7D%7BSupport%28X%29%2ASupport%28Y%29%7D%3D%5Cfrac%7B%5Cfrac%7B%E5%90%8C%E6%97%B6%E5%8C%85%E5%90%ABXY%E7%9A%84%E6%95%B0%E6%8D%AE%E6%95%B0%7D%7B%E6%95%B0%E6%8D%AE%E6%80%BB%E6%95%B0%7D%7D%7B%5Cfrac%7B%E5%8C%85%E5%90%ABX%E7%9A%84%E6%95%B0%E6%8D%AE%E6%95%B0%7D%7B%E6%95%B0%E6%8D%AE%E6%80%BB%E6%95%B0%7D%5Cfrac%7B%E5%8C%85%E5%90%ABY%E7%9A%84%E6%95%B0%E6%8D%AE%E6%95%B0%7D%7B%E6%95%B0%E6%8D%AE%E6%80%BB%E6%95%B0%7D%7D)

![[公式]](https://www.zhihu.com/equation?tex=leverage%28X%5Crightarrow+Y%29%3DSupport%28X+%5Crightarrow+Y%29-Support%28X%29%2ASupport%28Y%29%3D%5Cfrac%7B%E5%90%8C%E6%97%B6%E5%8C%85%E5%90%ABXY%E7%9A%84%E6%80%BB%E6%95%B0%7D%7B%E6%95%B0%E6%8D%AE%E6%80%BB%E6%95%B0%7D-%5Cfrac%7B%E5%8C%85%E5%90%ABX%E7%9A%84%E6%80%BB%E6%95%B0%7D%7B%E6%95%B0%E6%8D%AE%E6%80%BB%E6%95%B0%7D%2A%5Cfrac%7B%E5%8C%85%E5%90%ABY%E7%9A%84%E6%80%BB%E6%95%B0%7D%7B%E6%95%B0%E6%8D%AE%E6%80%BB%E6%95%B0%7D)

![[公式]](https://www.zhihu.com/equation?tex=Conviction%28X%5Crightarrow+Y%29%3D%5Cfrac%7B1-Support%28Y%29%7D%7B1-Confidence%28X%5Crightarrow+Y%29%7D%3D%5Cfrac%7B1-%5Cfrac%7B%E5%8C%85%E5%90%ABY%E7%9A%84%E6%95%B0%E9%87%8F%7D%7B%E6%95%B0%E6%8D%AE%E6%80%BB%E6%95%B0%7D%7D%7B1-%5Cfrac%7B%E5%90%8C%E6%97%B6%E5%8C%85%E5%90%ABXY%E7%9A%84%E6%95%B0%E9%87%8F%7D%7B%E5%8C%85%E5%90%ABX%E7%9A%84%E6%95%B0%E9%87%8F%7D%7D)

提升度left一般大于1才认为有效，确信度conviction越大，先导项与后继项的关联性越强。

以上三个指标越大，关联强度越大。

下面将使用Python实现Aprior算法。

```python
import numpy as np
import pandas as pd
from mlxtend.preprocessing import TransactionEncoder

shopping_list = [['大豆','白菜'],
            ['白菜','尿布','葡萄酒','甜瓜'],
            ['大豆','尿布','葡萄酒','橙汁'],
            ['白菜','大豆','尿布','葡萄酒'],
            ['白菜','大豆','尿布','橙汁']]
# 转换成数据框
shopping_df = pd.DataFrame(shopping_list)

# 定义将DataFrame恢复为原始ndarray的函数
def deal(data):
    return data.dropna().tolist()
df_arr = shopping_df.apply(deal,axis=1,).tolist()

# 购物编码器
te = TransactionEncoder()
df_tf = te.fit_transform(df_arr)
df = pd.DataFrame(df_tf,columns=te.columns_)
df
```

![](https://pic4.zhimg.com/80/v2-38c4ebcd01bca98f8e208664f9a8a9f3_1440w.jpg)

```python
# 求频繁项集
from mlxtend.frequent_patterns import apriori
frequent_itemsets = apriori(df,min_support=0.05,use_colnames=True)  # 定义最小支持度为0.05
frequent_itemsets.sort_values(by='support',ascending=False,inplace=True)
frequent_itemsets
```

![](https://pic3.zhimg.com/80/v2-e80e7cbe5aeb33d57293d4a00ac35972_1440w.jpg)

```python
# 求关联规则
from mlxtend.frequent_patterns import association_rules
association_rule = association_rules(frequent_itemsets,metric='confidence',min_threshold=0.9)
association_rule.sort_values(by='leverage',ascending=False,inplace=True)

association_rule
```

![](https://pic2.zhimg.com/80/v2-caa4561c648408edef6acc46594f7dfd_1440w.jpg)

至此可以得到以上购物行为的关联规则。

可见该商场的顾客买了橙汁以后很有可能会继续购买大豆和尿布，且购买葡萄酒后大概率会购买尿布。

## **参考资料**

[1] [推荐系统实践(三)----基于关联规则分析的推荐算法(Apriori)_未名湖畔的落叶-CSDN博客_基于关联规则的推荐算法](https://link.zhihu.com/?target=https%3A//blog.csdn.net/keyue123/article/details/86504122)

[2] [利用mlxtend进行数据关联分析_昆兰.沃斯 的博客-CSDN博客_mlxtend](https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_36523839/article/details/83960195)
